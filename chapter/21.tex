\section{转换工具的实现}

本章主要讲述第 \ref{sec:dcfgconv} 节的算法 \ref{alg:eg:dfgllvm} 
在工具里的实现，并给出了重要的部分：

\subsection{核心类 \code{Analyzer} 的定义}
定义相关的代码如下所示：

{
    \setstretch{1.0}
    \lstinputlisting[style=lstcpp]{code/Analyzer.hpp}
}

下面分别解释每一部分的含义：

类型 \code{__timeidx}：此类型所表示的变量，指的是变量在时间上的位置。如果变量经过了计算而发生了改变，则它在时间上的位置增加1.

类型 \code{__var_addr}：此类型的命名来自于LLVM的 \code{llvm::Value*} 的定义。即把一个虚拟寄存器的存在看作一个指针（地址）。

类型 \code{_var_synonyms}：此类型指的是虚拟寄存器同义词列表。所有在时间与空间上等价的变量都加在同一个列表中。

类型 \code{_var_name}：此类型指的是虚拟寄存器的名字。这个名字来自于C/C++的源代码。因为LLVM的bitcode的特性，这个名字总是不存在的或唯一的。

类型 \code{_var}：此类型代表一个变量。它将变量的名字和所有的同义词联系了起来。

类型 \code{_var_array}：此类型代表变量的列表。用来存储所有遇到的变量。

类型 \code{_cond_type}：这里表示流程的属性。此属性来自于代码中的分支指令。将默认指向的分支设置为Common（通常）属性，将其他剩余的分支设置为Inhibit（抑制）属性。

类型 \code{__edge_link}：此类型表示的是两个节点之间的连线。

类型 \code{__edge_type}：此类型表示的是连线的属性，并应用了通常属性或者抑制属性。

类型 \code{_edge}：此类型综合表示了连线与属性，代表了一个完整的有向弧。

类型 \code{_edge_array}：此类型表示了所有的连线，程序分析出的有向弧全部保存在这里。

类型 \code{__basic_block}：此类型表示了带有属性的分支的第一个指令。属性包括Common与Inhibit。

类型 \code{_basic_block_array}：此类型表示程序所有的分支，所有分析出的分支都保存在这里。

下节解释每个方法完成的工作。

\subsection{类 \code{Analyzer} 中方法的详细说明}

本节讲述 Analyzer 类的具体实现的核心部分。下面的代码表示了程序结构图的生成过程。

{
    \setstretch{1.0}
    \lstinputlisting[style=lstcpp]{code/Analyzer.cpp}
}

方法 \code{onAlloca}：LLVM中，Alloca指令是为一个新变量分配虚拟寄存器，
所以，这个方法用来创建一个新变量。它在变量的存储中开辟一个空间，并把代表变量的地址保存进去。

方法 \code{onLoad}：这个方法用来添加变量的同义词。Load指令不会改变变量，因此可以断定，
它必然会产生同义词。要注意的是，Load操作因为不会修改变量，因此变量的时间位置不变。

方法 \code{onStore}：这个方法同样是添加变量的同义词。不同的是，它会同时增加变量的时间位置。
LLVM代码中，变量只有在变动之后才会出现Store指令。这就有两个优势：
一是此处可以断定Store指令导致时间位置增加，二是在这里定义时间位置要比在 \code{onBinary} 处
和 \code{onCall} 处定义更加方便。
此方法还对变量的名称有影响：当函数要读取传入的参数时，会先分配一个匿名的寄存器，再将有名字的
传入参数Store到寄存器中。这一点是与通常的Alloca操作不同的地方。所以遇到这种操作时，变量的
命名由这个方法完成。

方法 \code{onBinary}：这个方法将1个变量依赖于2个变量存储在图中。并设置边的属性。
边的属性由当前分支的属性决定。要注意的是，设置好一次属性后，要从列表中删除这个属性。
否则的话，与当前分支的所有边都会设为这个属性，这与实际不符。

方法 \code{onBranch}：这个方法用来保存代码分支，并同时保存它的Common或Inhibit属性。
这两个属性可以由方法\code{llvm::TerminatorInst::getNumSuccessors}的结果推断出来。
在代码的最上方给出了属性的获取方法。

方法 \code{onCall}：这个方法的行为与\code{onBinary}非常相似。
\code{onBinary} 所表示的是1个变量依赖于2个变量，而此方法表示的是1个变量依赖于多个变量。
因此处理的方法与 \code{onBinary} 相似。要注意的是，函数的参数数量是不定的，
所以这里使用了 \code{std::vector} 来保存多个被依赖的值。
